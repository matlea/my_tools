"""
This is a rewritten version of an old myBLpol.

Contains:
    ray2constants()     A method generate E, rs, rp, delta files from RAY csv files.
    Beamline()          A class that use the files generated by ray2constants().
                        It can also use the 5 column files generated by the old ray2constants().
    plotEllipses()      A method that plots polarization ellipses.
    
"""

__version__ = "2025.03.05"
__author__ = "matlea"


import numpy as np
import matplotlib.pyplot as plt
import csv
from colorama import Fore

from matplotlib.ticker import MultipleLocator
from matplotlib import cm 
from matplotlib.patches import Ellipse
import matplotlib.colors as mcolors

import logging # just to learn how to use logger...
logging.basicConfig(level = logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s',
                    handlers = [logging.StreamHandler(), logging.FileHandler(filename = "logfile.log", mode = "a")])



# ======================================= For calculating and exporting optical constants rs,rp and d
#                                         from a Ray Scalar Beam Properties csv file to a txt file.



def ray2constants(csv_file = 'file.csv', rays = 1, out_file = 'coeffs.txt', header = 'header', graph = True, shup = True):
    """
    Calculate effective rs,rp, and d from a Ray Scalar Beam Properties csv file.

    The data in the csv file must be generated with circular polarized light ([0,0,1]).

    The csv file should be from the last optical element of interest. It should contain the scan parameter as a column (photon energy).

    The rays should contain the number of rays from the source (like 500000 or 20000000 or whatever).

    The output is saved as a 4-columns file: energy, rs, rp, and phase shift.
    
    """

    if not (type(csv_file) is str and type(header) is str and type(out_file) is str):
        logging.error("ray2constants(): Arguments csv_file, header, and out_file must be strings.")
        return False

    try: headerL = header.split(';')
    except: headerL = [header]
    
    if len(out_file) < 1:
        out_file = 'coeffs.txt'
    
    if rays == 1:
        logging.warning("ray2constants(): Don't forget to pass rays as the number of rays from the source.")

    # Load and extract data from a Ray Scalar Beam Properties csv file

    cols = [1,26,31,32,33]
    fields = []
    rows = []
    try:
        with open(csv_file, 'r') as csvfile: 
            csvreader = csv.reader(csvfile) 
            tmp = next(csvreader)
            fields = next(csvreader)
            fields = list(fields[0].split("\t"))
            for row in csvreader: 
                rows.append(row)
            csvfile.close
    except:
        logging.error(f"ray2constants(): Error when trying to open or read the file {csv_file}")
        return False

    try:
        size1, size2 = np.shape(rows)
        if size1<1 or size2<1:
            logging.error("ray2constants(): Unexpected error when trying to read from file.")
            return False
    except:
        logging.error("ray2constants(): Unexpected error when trying to read from file.\n\tCheck file contents.")
        return False

    try:
        Y = []
        for row in rows:
            R = list(row[0].split("\t")) 
            y = []
            for c in cols:
                y.append(float(R[c]))
            Y.append(y)
        Y = np.transpose(Y)
    except:
        logging.error('ray2constants(): Unexpected error when trying to extract data from file {0}'.format(csv_file))
        return False
    
    data_E = Y[0]
    data_Eff = Y[1]/rays
    data_S1 = Y[2]
    data_S2 = Y[3]
    data_S3 = Y[4]
    del Y

    # Caclulate and write to file

    F = open(out_file, 'w')
    F.write('# calculated optical constants\n')
    F.write('# columns: E, rs, rp, ∆\n')
    F.write('# \n')
    
    if len(headerL)>0:
        for h in headerL:
            F.write(f"# {h}\n")
        F.write('# \n')

    RS = []; RP = []; D = []
    for i, e in enumerate(data_E):
        nrm = np.sqrt( data_S1[i]**2 + data_S2[i]**2 + data_S3[i]**2)
        S = np.array([ 1, data_S1[i]/nrm, data_S2[i]/nrm, data_S3[i]/nrm ]) 
        S = S * data_Eff[i]/100
        rs = np.sqrt( 0.5 * (S[0] + S[1]) )
        rp = np.sqrt( 0.5 * (S[0] - S[1]) )
        try: d = np.rad2deg(np.arctan2(S[2],S[3]))
        except: d = 0
        #try: d2 = np.rad2deg(np.arcsin(S[2]/(2*rs*rp)))
        #except: d2 = np.NaN
        #try: d3 = np.rad2deg(np.arccos(S[3]/(2*rs*rp)))
        #except: d3 = np.NaN
        RS.append(rs); RP.append(rp); D.append(d)
        stR = f"{e:5.1f}\t{rs:8.5f}\t{rp:8.5f}\t{d:7.4f}\n"
        F.write(stR)
        if not shup: print(stR[:-1])
    F.close()

    # plot results, if argument 'graph' is True

    if graph:
        fig, ax = plt.subplots(ncols = 2, figsize = (7,3))
        ax[0].plot(data_E, RS, label = 'rs')
        ax[0].plot(data_E, RP, label = 'rp')
        ax[1].plot(data_E, D, label = 'phase shift')
        ax[0].set_ylabel('reflectivity')
        ax[1].set_ylabel('angle (°)')
        for a in ax:
            a.set_xlabel('energy (eV)')
            a.legend()
        fig.tight_layout()







class Beamline():
    """
    Properties:
        e       get, set    float, photon energy (can also use .energy)
        Sin     get, set    array, Stokes vector from the EPU
        Sout    get, set    array, Stokes vector at the sample
        eff     get         float, beamline efficiency
        rs      get, set    float, rs value (*)
        rp      get, set    float, rp value (*)
        d       get, set    float, phase shift in degrees (*)
        M       get         array, beamline matrix
        M_      get         array, inverse beamline matrix

        values  get         dict, all set and calculated values

        E       get         all tabulated energies
        RP      get         all tabulated rs values
        RS      get         all tavulated rp values
        D       get         all tabulated phase shift values

        plot    get, set    ax, plots the polarization ellipse(s). set it to 0, 1, or 2 (Sin and Sout, Sin, or Sout)
        plot_constants  get ax, plots the tabulated rs, rp, and d values.


        (*) When these properties are set M and eff are calculated, and Sout is calculated from current Sin.
    """
    def __init__(self, filename = "", shup = False):
        """
        """
        self._shup = False
        self._filename = ""
        self._data_e = []
        self._data_rs = []
        self._data_rp = []
        self._data_d = []
        self._Sin = np.ones([4])*np.NaN
        self._Sout = np.ones([4])*np.NaN
        self._matrix = np.ones([4,4])*np.NaN
        self._eff = np.NaN
        self._e = np.NaN
        self._rs = np.NaN
        self._rp = np.NaN
        self._d = np.NaN
        #
        self._plot_type = 0 # 0: Sin and Sout, 1: Sin, 2: Sout
        #
        if not type(shup) is bool: shup = False
        self._shup = shup
        #
        if not type(filename) is str:
            logging.error("Beamline(): Argument filename must be a string."); return
        self._filename = filename
        if not self._loadData():
            return
        # ---- start values
        self._e = self._data_e[-1]
        self._rs = self._data_rs[-1]
        self._rp = self._data_rp[-1]
        self._d = self._data_d[-1]
        self._makeMatrix()
        self.Sin = [1,0,0,1]
        # ---
    
    def __str__(self):
        txt = "Getable properties:\n"
        txt = f"{txt}  e, rp, rs, d, eff, Sin, Sout, M\n"
        txt = f"{txt}  values, plot\n"
        txt = f"{txt}Setable properties:\n"
        txt = f"{txt}  e, rp, rs, d, Sin, Sout\n"
        txt = f"{txt}  plot\n"
        txt = f"{txt}Setting...\n"
        txt = f"{txt}  ...e retrieves calculated values for rp, rs, and d, and calculates M, eff, and Sout.\n"
        txt = f"{txt}  ...Sin calculates Sout and eff, and setting Sout calculates Sin and eff.\n"
        txt = f"{txt}  ...rp, rs, and/or d calculates M, eff, and Sout.\n"
        txt = f"{txt}Property value is a dict containing all properties.\n"
        txt = f"{txt}Property plot is a plot. You can chose its content by setting it to 0, 1, or 2.\n"
        return txt
    
    def __repr__(self):
        print(Fore.BLUE + f"e    = {self.e:9.5f}")
        print(f"rp   = {self.rp:9.5f}")
        print(f"rs   = {self.rs:9.5f}")
        print(f"d    = {self.d:9.5f}°")
        print(f"eff  = {self.eff:9.5f}")
        print(f"Sin  = {self.Sin}")
        print(f"Sout = {self.Sout}" + Fore.RESET)
        return("")

    
    def _loadData(self):
        try:
            data = np.loadtxt(self._filename).transpose()
            if len(data) == 4:
                self._data_e, self._data_rs, self._data_rp, self._data_d = data[0], data[1], data[2], data[3]
            elif len(data) == 5: # old style tables
                self._data_e, self._data_rs, self._data_rp, self._data_d = data[0], data[2], data[3], data[4]
            logging.info(f"Beamline(): Loaded optical data from file {self._filename}.")
            return True
        except:
            self._data_e, self._data_rs, self._data_rp, self._data_d = [1000], [1], [1], [0]
            logging.error(f"Beamline(): Could not load data from file {self._filename}.")
            return False
    
    def _makeMatrix(self):
        m11 = 0.5 * ( self.rs**2 + self.rp**2 )
        m12 = 0.5 * ( self.rs**2 - self.rp**2 )
        m33 = 1 * self.rs * self.rp * np.cos( np.deg2rad(self.d) )
        m34 = 1 * self.rs * self.rp * np.sin( np.deg2rad(self.d) )
        M = [[m11, m12, 0, 0], [m12, m11, 0, 0], [0, 0, m33, m34], [0, 0, -m34, m33]]
        self._matrix = np.round(np.array(M),5)
    
    @property
    def e(self):
        return self._e
    @e.setter 
    def e(self, value):
        try: value = float(abs(value))
        except:
            logging.error("Beamline(): The e property must be a number."); return
        indx = abs(self._data_e - value).argmin()
        self._e = self._data_e[indx]
        if not value == self._e and not self._shup:
            if not self._shup: logging.info(f"Beamline(): Note that {value} eV is not tabulated. Using the closest value, {self._e} eV.")
        self._rs = self._data_rs[indx]
        self._rp = self._data_rp[indx]
        self._d = self._data_d[indx]
        self._makeMatrix()
        self.Sin = self._Sin
    
    @property
    def energy(self): return self.e

    @energy.setter 
    def energy(self, value): self.e = value

    @property 
    def Sin(self):
        return self._Sin
    @Sin.setter 
    def Sin(self, value):
        if not (type(value) is list or type(value) is np.ndarray):
            logging.error("Beamline(): The Sin property must be a list or array of length 3 or 4."); return
        if not len(value) in [3,4]:
            logging.error("Beamline(): The Sin property must be a list or array of length 3 or 4."); return
        if len(value) == 3:
            s0 = np.sqrt(value[0]**2 + value[1]**2 + value[2]**2)
            self._Sin = np.array([1, value[0]/s0, value[1]/s0, value[2]/s0])
        else:
            s0 = np.sqrt(value[1]**2 + value[2]**2 + value[3]**2)
            self._Sin = np.array([1, value[1]/s0, value[2]/s0, value[3]/s0])
        S = self._matrix.dot(self._Sin)
        self._eff = S[0]
        s0 = np.sqrt(S[1]**2 + S[2]**2 + S[3]**2)
        self._Sout = np.array([1, S[1]/s0, S[2]/s0, S[3]/s0])
    
    @property 
    def Sout(self):
        return self._Sout
    @Sout.setter 
    def Sout(self, value):
        if not (type(value) is list or type(value) is np.ndarray):
            logging.error("Beamline(): The Sout property must be a list or array of length 3 or 4."); return
        if not len(value) in [3,4]:
            logging.error("Beamline(): The Sout property must be a list or array of length 3 or 4."); return
        if len(value) == 3:
            s0 = np.sqrt(value[0]**2 + value[1]**2 + value[2]**2)
            self._Sout = np.array([1, value[0]/s0, value[1]/s0, value[2]/s0])
        else:
            s0 = np.sqrt(value[1]**2 + value[2]**2 + value[3]**2)
            self._Sout = np.array([1, value[1]/s0, value[2]/s0, value[3]/s0])
        S = np.linalg.inv(self._matrix).dot(self._Sout)
        self._eff = 1/S[0]
        s0 = np.sqrt(S[1]**2 + S[2]**2 + S[3]**2)
        self._Sin = np.array([1, S[1]/s0, S[2]/s0, S[3]/s0])

    @property
    def rs(self):
        return self._rs 
    @rs.setter
    def rs(self, value):
        try: value = abs(float(value))
        except:
            logging.error("Beamline(): The rs property must be a positive number."); return
        self._rs = value
        self._makeMatrix()
        self.Sin = self._Sin
    
    @property
    def rp(self):
        return self._rp
    @rp.setter
    def rp(self, value):
        try: value = abs(float(value))
        except:
            logging.error("Beamline(): The rp property must be a positive number."); return
        self._rp = value
        self._makeMatrix()
        self.Sin = self._Sin
    
    @property
    def d(self):
        return self._d
    @d.setter
    def d(self, value):
        try: value = float(value)
        except:
            logging.error("Beamline(): The d property must be a number (deg.)."); return
        self._d = value
        self._makeMatrix()
        self.Sin = self._Sin
    
    @property
    def eff(self):
        return self._eff
    @eff.setter
    def eff(self, *args):
        logging.warning("Beamline(): The eff property is calculated and can not be set."); return

    @property
    def M(self):
        return self._matrix
    @M.setter
    def M(self, *args):
        logging.warning("Beamline(): The M property is calculated and can not be set."); return
    
    @property
    def M_(self):
        return np.linalg.inv(self._matrix)
    @M_.setter
    def M_(self, *args):
        logging.warning("Beamline(): The M_ property is calculated and can not be set."); return
    
    @property
    def plot(self):
        if self._plot_type == 0:
            if not (np.isnan(self.Sin[0]) or np.isnan(self.Sout[0])):
                plotEllipses(S = [self.Sin, self.Sout])
        elif self._plot_type == 1:
            if not np.isnan(self.Sin[0]):
                plotEllipses(S = [self.Sin])
        elif self._plot_type == 2:
            if not np.isnan(self.Sout[0]):
                plotEllipses(S = [self.Sout])
    @plot.setter
    def plot(self, value):
        errmsg = "Beamline(): The property is an integer. 0: plot both Sin and Sout, 1: plot Sin, 2: plot Sout"
        if not type(value) is int:
            logging.error(errmsg); return
        if not value in [0,1,2]:
            logging.error(errmsg); return
        self._plot_type = value
        self.plot
    
    @property
    def values(self):
        return {"e":  self.e,
                "rp": self.rp,
                "rs": self.rs,
                "d":  self.d,
                "eff": self.eff,
                "Sin": self.Sin,
                "Sout": self.Sout,
                "M": self.M}
    
    # ---- extra properties ----
    def _property_can_not_be_set(self, prop = "[property]"): logging.warning(f"Beamline(): Property {prop} can not be set.")

    @property
    def E(self): return self._data_e
    @E.setter
    def E(self, *args): self._property_can_not_be_set("E")
    @property
    def RS(self): return self._data_rs
    @RS.setter
    def RS(self, *args): self._property_can_not_be_set("RS")
    @property
    def RP(self): return self._data_rp
    @RP.setter
    def RP(self, *args): self._property_can_not_be_set("RS")
    @property
    def D(self): return self._data_d
    @D.setter
    def D(self, *args): self._property_can_not_be_set("D")
    @property
    def plot_constants(self):
        fig, ax = plt.subplots(figsize = (5,3))
        ax.plot(self.E, self.RP, label = "rp")
        ax.plot(self.E, self.RS, label = "rs")
        axt = ax.twinx()
        axt.plot(self.E, self.D, color = "k", linestyle = "--")
        ax.set_xlabel("Energy, eV")
        ax.set_ylabel("Reflectivity")
        axt.set_ylabel("Phase shift, deg")
        ax.legend(fontsize = 9)
        fig.tight_layout()
    @plot_constants.setter
    def plot_constants(self, *args): self._property_can_not_be_set("D")
    
    @property
    def shup(self):
        return self._shup
    @shup.setter
    def shup(self, value):
        if not type(value) is bool:
            logging.error("Beamline(): The shup property is a bool."); return
        self._shup = value

        


def plotEllipses(S = [], ax = None, **kwargs):
    """
    """
    errmsg = "Argument S must be a list of Stokes vectors (of size 4). "
    errmsg = f"{errmsg}I.e. if you want to plot one ellipse you still need to pass."
    errmsg = f"{errmsg}S = [[s0,s1,s2,s3]]. To plot more than one ellipse you pass "
    errmsg = f"{errmsg}S = [[s0,s1,s2,s3], [t0,t1,t2,t3],]. That's it"
    if not type(S) is list:
        logging.error("plotEllipses(): Argument S must be a list of Stokes vectors (length 4)."); return
    if len(S) == 0:
        logging.error("plotEllipses(): Argument S must be a list of Stokes vectors (length 4)."); return
    for s in S:
        if not (type(s) is list or type(s) is np.ndarray):
            logging.error("plotEllipses(): Argument S must be a list of Stokes vectors (length 4)."); return
        if not len(s) == 4:
            logging.error("plotEllipses(): Argument S must be a list of Stokes vectors (length 4)."); return
    #
    fig = None
    if type(ax) is type(None):
        fig, ax = plt.subplots(figsize = (3,3))
    ax.spines['left'].set_position('center')
    ax.spines['right'].set_color('none')
    ax.spines['bottom'].set_position('center')
    ax.spines['top'].set_color('none')
    ax.xaxis.set_ticks_position('bottom')
    ax.yaxis.set_ticks_position('left')
    ax.set_xticks([-1.0, -.5, .5, 1.0])
    ax.set_yticks([-1.0, -.5, .5, 1.0])
    ax.set_xlim(-1.1, 1.1)
    ax.set_ylim(-1.1, 1.1)

    #alphas = list(np.linspace(0.5,1,len(S)))
    #colors = [ cm.jet(x) for x in np.linspace(0.5,1,len(S)) ]

    tmp_colors = []
    if "colors" in kwargs:
        tmp_colors = kwargs.get("colors", [])
        if not type(tmp_colors) is list: tmp_colors = []
        if not len(tmp_colors) == len(S): tmp_colors = []
        colors = tmp_colors
    if len(tmp_colors) == 0:
        colors = ['blue', 'orange', 'green', 'red', 'k', 'tab:blue', 'tab:orange', 'tab:green', 'tab:red']
    
    
    for c,s in enumerate(S):
        s = np.array(s)
        PL = np.round(np.sqrt(s[1]**2 + s[2]**2),6)
        A = np.sqrt(.50000*(1. + PL))
        B = np.sqrt(.50000*(1. - PL))
        Psi = 0.5*np.arctan2(s[2],s[1]) *np.rad2deg(1.)
        ell = Ellipse((0, 0), 2*A, 2*B, angle = Psi, lw = 1.5, edgecolor = colors[np.mod(c,len(colors))], facecolor = "none")
        ell.set_fill(False)
        ell.set_clip_box(ax.bbox)
        ax.add_artist(ell)
    
    if not type(fig) is type(None): fig.tight_layout(pad = 2.5) 
    return ax


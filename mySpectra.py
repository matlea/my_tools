
"""
Functions for loading and/or viewing .dc(0) and .dta files generated by Spectra.

All function are based on the assumption that the data comes from Spectra. The
one dim. files (.dc0) shall have the following columns:

Energy, Flux, PL, PC, PL45, 1-|PL|

and the two dim files (.dta) should have:

theta_x, theta_y, F.Density, PL, PC, PL45, 1-|PL|

or similar x and y columns for position instead of angle.



"""


import re
import numpy as np
from matplotlib import pyplot as plt



# =======================================

def load1p(fn='', shup = False):
    return load1d(fn=fn, shup=shup)

def load1d(fn='', shup=False):
    """
    Loads data from a dc0 file and return it as an array with the contents:

    energy, flux, LP, CP, PL45, 1-|PL|

    """

    try:
        with open(fn, 'r') as f:
            x = f.readlines()
    except:
        if not shup:
            print('Could not find/open {0}'.format(fn))
        return
    
    data = []
    for i in range(10,len(x)):
        tmp = []
        for X in x[i].split():
            tmp.append(float(X))
        data.append(tmp)

    data = np.array(data)
    return data

# =======================================

def load2p(fn = '', out = 'flux', numofheaderlines = 10, progress = False, pN = 1000):
    return load2d(fn = fn, out = out, numofheaderlines = numofheaderlines, progress = progress, pN = pN )

def load2d(fn = '', out = 'flux', numofheaderlines = 10, progress = False, pN = 1000):
    """
    Bla bla bla
    """
    try:
        with open(fn, 'r') as f:
            DATA = f.readlines()
    except:
        print('Could not find/open {0}'.format(fn))
        return None
    
    cols = ['Flux density', 'PL', 'PC', 'PL45', '|1-PL|' ]
    col = -1
    out = out.lower()
    if out == cols[0].lower() or out[0:2] == cols[0].lower()[0:2]:
        col = 2
    if out == cols[1].lower():
        col = 3
    if out == cols[2].lower():
        col = 4
    if out == cols[3].lower():
        col = 5
    if out == cols[4].lower() or out == cols[4].lower()[1:5]:
        col = 6
    if col == -1:
        print("Pass argument 'out' as one of {0}".format(cols))
        return None
    
    DATA = DATA[numofheaderlines:]
    
    # Array of strings to array of floats
    # There is probably a better and fancier way to do the following, but...
    if progress: print('Load')
    DATA2 = []      
    for i, D in enumerate(DATA):
        tmp = []
        Ds = D.split()
        if len(Ds) <3: break
        for j, d in enumerate(Ds):
            tmp.append( np.float(d))
        DATA2.append(tmp)
        if progress:
            if np.mod(i,pN) == 0: 
                print(i)
    if progress: print(i)
    DATA = np.array(DATA2)
    del DATA2

    # Make a 2D map
    # There is probably a better and fancier way to do the following, but...
    if progress: print('Make map')
    X = np.unique(DATA[:,0])
    Y = np.unique(DATA[:,1])
    Z = np.zeros( [len(X), len(Y)])
    c = 0
    for ix, x in enumerate(X):
        for iy, y in enumerate(Y):
            tmp = DATA[ np.all( [DATA[:,0] == x, DATA[:,1] == y], axis=0)][0][col]
            Z[ix][iy] = tmp
            c += 1
            if progress:
                if np.mod(c,pN) == 0: print(c)
    Z = np.transpose(Z)
    if progress: 
        print(c)
        print('Done')
    return X, Y , Z


def loadRaw(fn = '', shup=False):
    """

    Bla bla bla
    
    """

    try:
        f = open(fn, 'r')
    except:
        print("\n\tCould not find or open file '{0}'".format(fn))
        return []
    try:
        content = f.read().split('\n')
    except:
        print("\n\tCould not read (properly) from file '{0}'".format(fn))
    f.close()
    
    DATA = []
    for i, row in enumerate(content):
        if i < 10:
            if not shup: print(row)
        else:
            try:
                floatRow = np.array( [float(x) for x in row.split()] )
                if len(floatRow) == 7:
                    DATA.append(floatRow)
            except:
                break
    
    return np.array(DATA)
    

    







# =======================================

#def load2d(path='',fn='',out='flux',plot=False,plotret=True,shup=False,flag=True):
def load2d_(fn='',out='flux',plot=False,plotret=True,shup=False,flag=True):
    """
    Loads data (kind specified with the out argument) from a dta file and
    return three arrays: x, y, and z, where x and y are 1d and z 2d.

    The path, if used, shall NOT end with a '/', and the file name fn
    shall have extension .dta.

    out can be (anything starting with, not case sensitive) f (flux density),
    pl4 (PL45), pl (PL), pc (PC), or 1-  (1-|PL|).

    Added: out can also be po or pw (power density).
    
    If plot==True a color map is printed. If plot ret==True WHEN plot==True,
    then the function also returns the values, otherwise not.

    When returning: three arrays: x (1d), y (1d), and z (2d).
    """

    fileName = fn
    try:
        with open(fileName, 'r') as f:
            x = f.readlines()
    except:
        if shup: return [], [], []
        raise Exception('\n\tCould not find/open ' + fileName)
    newFileName = fileName[:-4]+'.txt'
    with open(newFileName, 'w') as f:
        for i in range(0,9):
            f.write('# ' + x[i])
        for i in range(10,len(x)):
            f.write(x[i])  
    try:
        data = np.loadtxt(newFileName)
    except:
        if shup: return [], [], []
        raise Exception('\n\tCould not find/open ' + fn)
    data=data.transpose()
    
    N1 = np.nan
    for i in range(1,len(data[0])):
        if data[0][0] == data[0][i]:
            N1 = i
            break
    N2 = int(len(data[0])/N1)

    out = out.lower()
    col = np.nan
    outName = ['x','y','Flux density','PL','PC','PL45','1-|PL|','Power density']
    if out[0:1]=='f':       # flux
        col=2
    elif out[0:3]=='pl4':   # PL45
        col=5
    elif out[0:2]=='pl':    # PL
        col=3
    elif out[0:2]=='pc':    # PC
        col=4
    elif out[0:2]=='1-':    # 1-|PL|
        col=6
    elif out[0:2]=='po' or out[0:2]=='pw':
        col=2
    else:
        if shup: return [], [], []
        print('\n\tno such output\n')
        help(load2d)
        return

    mapX = np.zeros(N1)*np.nan
    mapY = np.zeros(N2)*np.nan
    mapZ = np.zeros((N1,N2))*np.nan

    mapX = data[0][0:N1]
    for i in range(0,N2-1):
        mapY[i]=data[1][i + i*N1]
    for i in range(0,N1-1):
        for j in range(0,N2):
            mapZ[i][j]=data[col][i+j*N1]
    mapZ = mapZ.transpose()

    if plot:
        fsy = 5
        fsx = 5 * (max(mapX)-min(mapX))/(max(mapY)-min(mapY))+0.75
        fig, ax = plt.subplots(figsize=(fsx,fsy))
        ax.set_title(outName[col])
        ax.set_ylabel('y')
        ax.set_xlabel('x')
        pc = ax.pcolor(mapX, mapY, mapZ)
        plt.colorbar(pc)
        if plotret:
            return mapX,mapY,mapZ
    else:
        return mapX,mapY,mapZ


# =======================================





# =======================================



def getPol2d(path='',fn='', plot=True, ret=False):
    """
    Work in progress. Works.
    """
    if fn=='':
        raise Exception('\n\tNo file name!')
    
    fileName = path + '/' + fn
    try:
        with open(fileName, 'r') as f:
            x = f.readlines()
    except:
        raise Exception('\n\tCould not find/open ' + fileName)
    newFileName = fileName[:-4]+'.txt'
    with open(newFileName, 'w') as f:
        for i in range(0,9):
            f.write('# ' + x[i])
        for i in range(10,len(x)):
            f.write(x[i])  
    try:
        data = np.loadtxt(newFileName)
    except:
        raise Exception('\n\tCould not find/open ' + fn)
    data=data.transpose()

    N1 = np.nan
    for i in range(1,len(data[0])):
        if data[0][0] == data[0][i]:
            N1 = i
            break
    N2 = int(len(data[0])/N1)

    mapX = np.zeros(N1)*np.nan
    mapY = np.zeros(N2)*np.nan
    mapZflux = np.zeros((N1,N2))*np.nan
    mapZs1 = np.zeros((N1,N2))*np.nan
    mapZs2 = np.zeros((N1,N2))*np.nan
    mapZs3 = np.zeros((N1,N2))*np.nan
    #mapZ1mPL = np.zeros((N1,N2))*np.nan

    mapX = data[0][0:N1]
    for i in range(0,N2-1):
        mapY[i]=data[1][i + i*N1]
    for i in range(0,N1-1):
        for j in range(0,N2):
            mapZflux[i][j]=data[2][i+j*N1]
            mapZs1[i][j]=data[3][i+j*N1]
            mapZs2[i][j]=data[5][i+j*N1]
            mapZs3[i][j]=data[4][i+j*N1]
            #mapZ1mPL[i][j] = data[6][i+j*N1]
    mapZflux = mapZflux.transpose()
    mapZs1 = mapZs1.transpose()
    mapZs2 = mapZs2.transpose()
    mapZs3 = mapZs3.transpose()
    #mapZ1mPL = mapZ1mPL.transpose()
    mapZup = 1 - np.sqrt(mapZs1**2 + mapZs2**2 + mapZs3**3)

    if plot:
        fig,ax = plt.subplots(2,3,figsize=(14,8))
        pc00 = ax[0][0].pcolor(mapX,mapY,mapZflux/1e15)
        pc01 = ax[0][1].pcolor(mapX,mapY,mapZs1)
        pc02 = ax[0][2].pcolor(mapX,mapY,mapZs2)
        pc03 = ax[1][0].pcolor(mapX,mapY,mapZs3, vmin=0, vmax=1)
        pc04 = ax[1][1].pcolor(mapX,mapY,-mapZs3, vmin=0, vmax=1)
        pc05 = ax[1][2].pcolor(mapX,mapY,mapZup)

        ax[0][0].set_title('Flux density (*1e-15)')
        ax[0][1].set_title('Linear polarization, S1')
        ax[0][2].set_title('Inclined polarization, S2')
        ax[1][0].set_title('Circular polarization, S3>0')
        ax[1][1].set_title('Circular polarization, S3<0')
        ax[1][2].set_title('1 - âˆš(S1^2+S2^2+S3^2)')

        plt.colorbar(pc00,ax=ax[0][0])
        plt.colorbar(pc01,ax=ax[0][1])
        plt.colorbar(pc02,ax=ax[0][2])
        plt.colorbar(pc03,ax=ax[1][0])
        plt.colorbar(pc04,ax=ax[1][1])
        plt.colorbar(pc05,ax=ax[1][2])
    
    if ret:
        return mapX, mapY, mapZflux, mapZs1, mapZs2, mapZs3, mapZup


# =======================================


def plot2dfile(path='',fn='',plot='flci'):
    '''
    A not very important function that plots selected data from a .dta file.

    The path, if used, shall NOT end with a '/', and the file name fn
    shall have extension .dc0.

    plot can be a sequence of f,l,c, and i. Eg. plot='lc' plots the linear, and
    circular polarization, plot='f' plots the flux density, a.s.o. Not case
    sensitive.

    Nothing is returned.
    '''
    if fn=='' or len(plot)==0:
        help(plot2dfile)
        return False
    try:
        with open(path+'/'+fn, 'r') as f:
            L = f.readlines()
        if not L[8].find('F.Density')>-1:
            print('\n\tThe file seems to be of the wrong kind.')
            print("\tBut let's try anyway...\n")
    except:
        print('\n\tCould not find, open, or read the file.')
        return False

    plot = plot.lower()
    note1 = []; note2 = []
    if plot.find('f')>-1:
        note1.append('f'); note2.append('Flux density')
    if plot.find('l')>-1:
        note1.append('pl'); note2.append('Linear polarization')
    if plot.find('c')>-1:
        note1.append('pc'); note2.append('Circular polarization')
    if plot.find('i')>-1:
        note1.append('pl45'); note2.append('Inclined polarization')
    X=[]; Y=[]; Z=[]
    for i,n in enumerate(note1):
        x,y,z = load2d(path=path,fn=fn,out=n,plot=False,flag=False)
        X.append(x); Y.append(y); Z.append(z)
    
    if note1 == []:
        print("\n\tplot must be 'f', 'l', 'c', and/or 'i'.")
        return False
    
    numPlots=len(note1)
    fig,ax = plt.subplots(1,numPlots,figsize=(numPlots*3,3))
    for i,z in enumerate(Z):
        ax[i].pcolor(X[i],Y[i],Z[i])
        ax[i].set_title(note2[i])
    

# =======================================


def quickPlot1d(x=[],y=[],xlbl='energy', ylbl='y',title=''):
    '''
    A function to for lazy people (like myself) to quickly 
    plot a 1d curve. Needs an x and y array, can take strings 
    for x and y labels, and title. That's it.

    x   1d array        xlbl    string (default 'energy')
    y   1d array        ylbl    string (default 'y')
                        title   string (default '')
    
    '''
    if x==[] or y==[]:
        help(quickPlot1d)
        return
    if not len(x) == len(y):
        print('\n\tx and y shall have the same size')
        return
    fig,ax = plt.subplots(figsize=(8,4))
    ax.plot(x,y)
    ax.set_xlabel(xlbl); ax.set_ylabel(ylbl)
    ax.set_title(title)



def quickPlot2d(x=[],y=[],z=[],xlbl='x', ylbl='y',zlbl='intensity'):
    '''
    A function to quickly plot a 2d intensity map. Needs x and y
    arrays for the axes, and a 2d array for the intensity. Can take
    strings for x and y labels, and title.

    x   1d array        xlbl    string (default 'x')
    y   1d array        ylbl    string (default 'y')
    z   2d array        zlbl    string (default 'intensity')
    
    '''
    if x==[] or y==[] or z==[]:
        help(quickPlot1d)
        return
    if not len(x) == len(y):
        print('\n\tx and y shall have the same size')
        return
    try:
        shx,shy = np.shape(z)
        dimerr=0
        if not len(x)==shx:
            print('\n\tthe x array does not match the intensity array')
            dimerr+=1
        if not len(y)==shy:
            print('\n\tthe y array does not match the intensity array')
            dimerr+=1
        if dimerr>0:
            return
    except:
        print('\n\tz shall be a 2d array')
        return

    fig,ax = plt.subplots(figsize=(5,4))
    pc=ax.pcolor(x,y,z)
    ax.set_xlabel(xlbl); ax.set_ylabel(ylbl)
    ax.set_title(zlbl)
    plt.colorbar(pc)
    return fig, ax
